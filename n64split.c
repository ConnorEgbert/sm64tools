#include <inttypes.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include "config.h"
#include "libmio0.h"
#include "mipsdisasm.h"
#include "n64graphics.h"
#include "utils.h"

#define N64SPLIT_VERSION "0.1a"

#define GEN_DIR     "gen"

typedef struct _arg_config
{
   char input_file[FILENAME_MAX];
   char config_file[FILENAME_MAX];
} arg_config;

// default configuration
static const arg_config default_args = 
{
   "", // input filename
   "sm64.config", // config filename
};

const char asm_header[] = 
   "# %s disassembly and split file\n"
   "# generated by n64split v%s - N64 ROM splitter\n"
   "\n"
   "# assembler directives\n"
   ".set noat      # allow manual use of $at\n"
   ".set noreorder # don't insert nops after branches\n"
   "\n";

static void print_spaces(FILE *fp, int count)
{
   int i;
   for (i = 0; i < count; i++) {
      fputc(' ', fp);
   }
}

static void write_behavior(FILE *out, unsigned char *data, rom_config *config, int s)
{
   unsigned int a, i;
   unsigned int len;
   unsigned int val;
   int beh_i;
   split_section *sec;
   behavior *beh;
   sec = &config->sections[s];
   beh = sec->extra;
   a = sec->start;
   beh_i = 0;
   while (a < sec->end) {
      if (beh_i < sec->extra_len) {
         unsigned int offset = a - sec->start;
         if (offset == beh[beh_i].offset) {
            fprintf(out, "%s: # %04X\n", beh[beh_i].name, beh[beh_i].offset);
            beh_i++;
         } else if (offset > beh[beh_i].offset) {
            ERROR("Warning: skipped behavior %04X \"%s\"\n", beh[beh_i].offset, beh[beh_i].name);
            beh_i++;
         }
      }
      switch (data[a]) {
         case 0x0C:
         case 0x2A:
         case 0x02:
         case 0x23:
         case 0x14:
         case 0x2F:
         case 0x04:
         case 0x27:
         case 0x37:
            len = 8;
            break;
         case 0x1C:
         case 0x2B:
         case 0x2C:
         case 0x29:
            len = 12;
            break;
         case 0x30:
            len = 20;
            break;
         default:
            len = 4;
            break;
      }
      val = read_u32_be(&data[a]);
      fprintf(out, ".word 0x%08X", val);
      // behavior 0x0C is a function pointer
      if (data[a] == 0x0C) {
         char label[128];
         val = read_u32_be(&data[a+4]);
         fill_addr_label(config, val, label, -1);
         fprintf(out, ", %s\n", label);
      } else {
         for (i = 4; i < len; i += 4) {
            val = read_u32_be(&data[a+i]);
            fprintf(out, ", 0x%08X", val);
         }
         fprintf(out, "\n");
      }
      a += len;
   }
}

static void write_level(FILE *out, unsigned char *data, rom_config *config, int s)
{
   char start_label[128];
   char end_label[128];
   char dst_label[128];
   split_section *sec;
   unsigned int ptr_start;
   unsigned int ptr_end;
   unsigned int dst;
   unsigned int a;
   int indent;
   int i;
   int beh_i;

   sec = &config->sections[s];

   beh_i = -1;
   // see if there is a behavior section
   for (i = 0; i < config->section_count; i++) {
      if (config->sections[i].type == TYPE_BEHAVIOR) {
         beh_i = i;
         break;
      }
   }
   a = sec->start;
   while (a < sec->end) {
      // length = 0 ends level script
      if (data[a+1] == 0) {
         break;
      }
      switch (data[a]) {
         case 0x00: // load and jump from ROM into a RAM segment
         case 0x01: // load and jump from ROM into a RAM segment
         case 0x17: // copy uncompressed data from ROM to a RAM segment
         case 0x18: // decompress MIO0 data from ROM and copy it into a RAM segment
         case 0x1A: // decompress MIO0 data from ROM and copy it into a RAM segment (for texture only segments?)
            ptr_start = read_u32_be(&data[a+4]);
            ptr_end = read_u32_be(&data[a+8]);
            fill_addr_label(config, ptr_start, start_label, 0);
            fill_addr_label(config,   ptr_end,   end_label, 1);
            fprintf(out, ".word 0x");
            for (i = 0; i < 4; i++) {
               fprintf(out, "%02X", data[a+i]);
            }
            if (0 == strcmp("behavior_data", start_label)) {
               fprintf(out, ", __load_%s, __load_%s", start_label, end_label);
            } else {
               fprintf(out, ", %s, %s", start_label, end_label);
            }
            for (i = 12; i < data[a+1]; i++) {
               if ((i & 0x3) == 0) {
                  fprintf(out, ", 0x");
               }
               fprintf(out, "%02X", data[a+i]);
            }
            fprintf(out, "\n");
            break;
         case 0x11: // call function
         case 0x12: // call function
            ptr_start = read_u32_be(&data[a+0x4]);
            fill_addr_label(config, ptr_start, start_label, -1);
            fprintf(out, ".word 0x%08X, %s # %08X\n", read_u32_be(&data[a]), start_label, ptr_start);
            break;
         case 0x16: // load ASM into RAM
            dst       = read_u32_be(&data[a+0x4]);
            ptr_start = read_u32_be(&data[a+0x8]);
            ptr_end   = read_u32_be(&data[a+0xc]);
            fill_addr_label(config, dst, dst_label, 0);
            fill_addr_label(config, ptr_start, start_label, 0);
            fill_addr_label(config, ptr_end, end_label, 1);
            fprintf(out, ".word 0x");
            for (i = 0; i < 4; i++) {
               fprintf(out, "%02X", data[a+i]);
            }
            fprintf(out, ", %s, %s, %s\n", dst_label, start_label, end_label);
            break;
         case 0x25: // load mario object with behavior
         case 0x24: // load object with behavior
            fprintf(out, ".word 0x%08X", read_u32_be(&data[a]));
            for (i = 4; i < data[a+1]-4; i+=4) {
               fprintf(out, ", 0x%08X", read_u32_be(&data[a+i]));
            }
            dst = read_u32_be(&data[a+i]);
            if (beh_i >= 0) {
               unsigned int offset = dst & 0xFFFFFF;
               behavior *beh = config->sections[beh_i].extra;
               for (i = 0; i < config->sections[beh_i].extra_len; i++) {
                  if (offset == beh[i].offset) {
                     fprintf(out, ", %s", beh[i].name);
                     break;
                  }
               }
               if (i >= config->sections[beh_i].extra_len) {
                  ERROR("Error: cannot find behavior %04X needed at offset %X\n", offset, a);
               }
            } else {
               fprintf(out, ", 0x%08X", dst);
            }
            fprintf(out, "\n");
            break;
         default:
            fprintf(out, ".word 0x%08X", read_u32_be(&data[a]));
            for (i = 4; i < data[a+1]; i+=4) {
               fprintf(out, ", 0x%08X", read_u32_be(&data[a+i]));
            }
            fprintf(out, "\n");
            break;
      }
      a += data[a+1];
   }
   // align to next 16-byte boundary
   if (a & 0x0F) {
      fprintf(out, "# begin %s alignment 0x%X\n", sec->label, a);
      fprintf(out, ".byte ");
      fprint_hex_source(out, &data[a], ALIGN(a, 16) - a);
      fprintf(out, "\n");
      a = ALIGN(a, 16);
   }
   fprintf(out, "# begin %s geo 0x%X\n", sec->label, a);
   // remaining is geo layout script
   indent = 0;
   while (a < sec->end) {
      switch (data[a]) {
         case 0x00: // end
         case 0x01:
         case 0x03:
         case 0x04:
         case 0x05:
         case 0x09:
         case 0x0B:
         case 0x0C:
         case 0x17:
         case 0x20:
            i = 4;
            break;
         case 0x02:
         case 0x0D:
         case 0x0E:
         case 0x14:
         case 0x15:
         case 0x16:
         case 0x18:
         case 0x19:
            i = 8;
            break;
         case 0x08:
         case 0x13:
         case 0x1C:
            i = 12;
            break;
         case 0x10:
         case 0x1F:
            i = 16;
            break;
         case 0x0F: // Kaze has 8
            i = 20;
            break;
         case 0x0A:
            i = 8;
            if (data[a+1]) {
               i += 4;
            }
            break;
         case 0x11:
         case 0x1D:
            i = 8;
            if (data[a+1] & 0x80) {
               i += 4;
            }
            break;
         default:
            i = 4;
            ERROR("WHY? %06X %2X\n", a, data[a]);
      }
      if (data[a] == 0x05 && indent > 1) {
         indent -= 2;
      }
      if (data[a] == 0x01) {
         indent = 0;
      }
      fprintf(out, ".byte ");
      print_spaces(out, indent);
      fprint_hex_source(out, &data[a], i);
      fprintf(out, "\n");
      if (data[a] == 0x04) {
         indent += 2;
      }
      a += i;
   }
}

static void disassemble_section(FILE *out, unsigned char *data, long len, split_section *sec, proc_table *procs, rom_config *config)
{
   // disassemble all the procedures
   unsigned int ram_address;
   unsigned int last_end;
   unsigned int end_address;
   int start_proc;
   int proc_idx;
   // find first procedure in section
   last_end = rom_to_ram(config, sec->start);
   for (start_proc = 0; start_proc < procs->count; start_proc++) {
      if (procs->procedures[start_proc].start >= last_end) {
         break;
      }
   }
   // disassemble each procedure
   end_address = rom_to_ram(config, sec->end);
   for (proc_idx = start_proc; proc_idx < procs->count; proc_idx++) {
      ram_address = procs->procedures[proc_idx].start;
      if (ram_address > last_end) {
         // TODO: put larger sections in .bins
         fprintf(out, "\n# unknown assembly section %X-%X (%06X-%06X) [%X]",
               last_end, ram_address, ram_to_rom(config, last_end), ram_to_rom(config, ram_address), ram_address - last_end);
         unsigned int a = ram_to_rom(config, last_end);
         int count = 0;
         while (a < ram_to_rom(config, ram_address)) {
            if ((count % 4) == 0) {
               fprintf(out, "\n .word 0x%08x", read_u32_be(&data[a]));
            } else {
               fprintf(out, ", 0x%08x", read_u32_be(&data[a]));
            }
            a += 4;
            count++;
         }
         fprintf(out, "\n# end unknown section\n");
      }
      // TODO: this is a workaround for the inner procedures __osPopThread, __osEnqueueThread, proc_80327D68
      if (procs->procedures[proc_idx].start != 0x80327D58 &&
          procs->procedures[proc_idx].start != 0x80327D68 &&
          procs->procedures[proc_idx].start != 0x80327D10) {
         if (ram_address < last_end) {
            ERROR("Warning: %08X < %08X\n", ram_address, last_end);
         }
         disassemble_proc(out, data, len, &procs->procedures[proc_idx], config);
      }
      last_end = procs->procedures[proc_idx].end;
      if (last_end >= end_address) {
         break;
      }
   }
}

static void generate_ld_script(rom_config *config)
{
   char ldfilename[512];
   FILE *fld;
   int i;
   sprintf(ldfilename, "%s/%s.ld", GEN_DIR, config->basename);
   fld = fopen(ldfilename, "w");
   if (fld == NULL) {
      ERROR("Error opening %s\n", ldfilename);
      exit(3);
   }
   fprintf(fld,
"OUTPUT_FORMAT (\"elf32-bigmips\", \"elf32-bigmips\", \"elf32-littlemips\")\n"
"OUTPUT_ARCH (mips)\n"
"\n"
"SECTIONS\n"
"{\n"
"   /* header and boot */\n"
"   .header 0x0 : AT(0x0) {\n"
"      * (.header);\n"
"      * (.boot);\n"
"   }\n"
"\n"
"   /* load MIO0 and level data at 0x800000 */\n"
"   .rodata 0x800000 : {\n"
"      FILL (0x01) /* fill unused with 0x01 */\n"
"      * (.mio0);\n"
"      * (.rodata);\n"
"      * (.data);\n"
"      * (.MIPS.abiflags);\n"
"      . = ALIGN(0x10);\n"
"   }\n"
"\n"
"   /* use segmented addressing for behaviors */\n"
"   .behavior 0x13000000 : AT( LOADADDR(.rodata) + SIZEOF(.rodata) ) {\n"
"      FILL (0x01) /* fill unused with 0x01 */\n"
"      * (.behavior);\n"
"      behavior_length = . - 0x13000000;\n"
"      /* default 4MB data (12MB ROM) */\n"
"      . = 0x400000 - SIZEOF(.rodata);\n"
"   }\n"
"   __load_behavior_data = LOADADDR(.behavior);\n"
"   __load_behavior_data_end = LOADADDR(.behavior) + behavior_length;\n"
"\n");
   for (i = 0; i < config->ram_count; i++) {
      unsigned int ram_start = config->ram_table[3*i];
      unsigned int ram_end = config->ram_table[3*i+1];
      unsigned int ram_to_rom = config->ram_table[3*i+2];
      unsigned int length = ram_end - ram_start + 1;
      unsigned int rom_start = ram_start - ram_to_rom;
      unsigned int rom_end = rom_start + length;
      fprintf(fld,
"   /* (0x%08X, 0x%08X, 0x%08X), // %06X-%06X [%X] */\n"
"   .text%08X 0x%08X : AT(0x%06X) {\n"
"      * (.text%08X);\n"
"   }\n"
"\n", ram_start, ram_end, ram_to_rom, rom_start, rom_end, length, ram_start, ram_start, rom_start, ram_start);
   }
   fprintf(fld, "}\n");

   fclose(fld);
}

static void split_file(unsigned char *data, unsigned int length, proc_table *procs, rom_config *config)
{
#define MAKEFILENAME GEN_DIR "/Makefile.gen"
#define BIN_DIR      GEN_DIR "/bin"
#define MIO0_DIR     GEN_DIR "/bin"
#define TEXTURE_DIR  GEN_DIR "/textures"
#define LEVEL_DIR    GEN_DIR "/levels"
#define BEHAVIOR_DIR GEN_DIR

   char asmfilename[512];
   char outfilename[512];
   char outfilepath[512];
   char mio0filename[512];
   char start_label[256];
   char maketmp[256];
   char *makeheader_mio0;
   char *makeheader_level;
   FILE *fasm;
   FILE *fmake;
   int s;
   int i, j;
   unsigned int a;
   unsigned int w, h;
   unsigned int last_end = 0;
   unsigned int ptr;
   int count;
   int level_alloc;
   split_section *sections = config->sections;

   // create directories
   make_dir(GEN_DIR);
   make_dir(BIN_DIR);
   make_dir(MIO0_DIR);
   make_dir(TEXTURE_DIR);
   make_dir(LEVEL_DIR);

   // open main assembly file and write header
   sprintf(asmfilename, "%s/%s.s", GEN_DIR, config->basename);
   fasm = fopen(asmfilename, "w");
   if (fasm == NULL) {
      ERROR("Error opening %s\n", asmfilename);
      exit(3);
   }
   fprintf(fasm, asm_header, config->name, N64SPLIT_VERSION);

   for (s = 0; s < config->section_count; s++) {
      split_section *sec = &sections[s];

      // error checking
      if (sec->start >= length || sec->end > length) {
         ERROR("Error: section past end: 0x%X, 0x%X (%s) > 0x%X\n",
               sec->start, sec->end, sec->label ? sec->label : "", length);
         exit(4);
      }

      // fill gaps between regions
      if (sec->start != last_end) {
         int gap_len = sec->start - last_end;
         INFO("Filling gap before region %d (%d bytes)\n", s, gap_len);
         fprintf(fasm, "L%06X:\n", last_end);
         // for small gaps, just output bytes
         if (gap_len <= 16) {
            fprintf(fasm, ".byte ");
            fprint_hex_source(fasm, &data[last_end], gap_len);
            fprintf(fasm, "\n");
         } else {
            sprintf(outfilename, "%s/%s.%06X.bin", BIN_DIR, config->basename, last_end);
            write_file(outfilename, &data[last_end], gap_len);
            fprintf(fasm, ".incbin \"%s\"\n", outfilename);
         }
      }

      // print section header for new RAM segments
      for (i = 0; i < config->ram_count; i++) {
         if (sec->start == (config->ram_table[3*i] - config->ram_table[3*i+2])) {
            fprintf(fasm, "\n.section .text%08X, \"ax\"\n\n", rom_to_ram(config, sec->start));
         }
      }

      switch (sec->type)
      {
         case TYPE_HEADER:
            INFO("Section header: %X-%X\n", sec->start, sec->end);
            fprintf(fasm, ".section .header, \"a\"\n"
                          ".byte  0x%02X", data[sec->start]);
            for (i = 1; i < 4; i++) {
               fprintf(fasm, ", 0x%02X", data[sec->start + i]);
            }
            fprintf(fasm, " # PI BSD Domain 1 register\n");
            fprintf(fasm, ".word  0x%08X # clock rate setting\n", read_u32_be(&data[sec->start + 0x4]));
            fprintf(fasm, ".word  0x%08X # entry point\n", read_u32_be(&data[sec->start + 0x8]));
            fprintf(fasm, ".word  0x%08X # release\n", read_u32_be(&data[sec->start + 0xc]));
            fprintf(fasm, ".word  0x%08X # checksum1\n", read_u32_be(&data[sec->start + 0x10]));
            fprintf(fasm, ".word  0x%08X # checksum2\n", read_u32_be(&data[sec->start + 0x14]));
            fprintf(fasm, ".word  0x%08X # unknown\n", read_u32_be(&data[sec->start + 0x18]));
            fprintf(fasm, ".word  0x%08X # unknown\n", read_u32_be(&data[sec->start + 0x1C]));
            fprintf(fasm, ".ascii \"");
            fwrite(&data[sec->start + 0x20], 1, 20, fasm);
            fprintf(fasm, "\" # ROM name: 20 bytes\n");
            fprintf(fasm, ".word  0x%08X # unknown\n", read_u32_be(&data[sec->start + 0x34]));
            fprintf(fasm, ".word  0x%08X # cartridge\n", read_u32_be(&data[sec->start + 0x38]));
            fprintf(fasm, ".ascii \"");
            fwrite(&data[sec->start + 0x3C], 1, 2, fasm);
            fprintf(fasm, "\"       # cartridge ID\n");
            fprintf(fasm, ".ascii \"");
            fwrite(&data[sec->start + 0x3E], 1, 1, fasm);
            fprintf(fasm, "\"        # country\n");
            fprintf(fasm, ".byte  0x%02X       # version\n\n", data[sec->start + 0x3F]);
            break;
         case TYPE_BIN:
            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(outfilename, "%s/%s.%06X.bin", BIN_DIR, config->basename, sec->start);
            } else {
               sprintf(outfilename, "%s/%s.%06X.%s.bin", BIN_DIR, config->basename, sec->start, sec->label);
            }
            write_file(outfilename, &data[sec->start], sec->end - sec->start);
            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(start_label, "L%06X", sec->start);
            } else {
               strcpy(start_label, sec->label);
            }
            fprintf(fasm, "%s:\n", start_label);
            fprintf(fasm, ".incbin \"%s\"\n", outfilename);
            fprintf(fasm, "%s_end:\n", start_label);
            break;
         case TYPE_GEO:
         case TYPE_MIO0:
            // fill previous geometry and MIO0 blocks
            fprintf(fasm, ".space 0x%05x, 0x01 # %s\n", sec->end - sec->start, sec->label);
            break;
         case TYPE_PTR:
            INFO("Section ptr: %X-%X\n", sec->start, sec->end);
            for (a = sec->start; a < sec->end; a += 4) {
               ptr = read_u32_be(&data[a]);
               fill_addr_label(config, ptr, start_label, -1);
               fprintf(fasm, ".word %s\n", start_label);
            }
            break;
         case TYPE_ASM:
            INFO("Section asm: %X-%X\n", sec->start, sec->end);
            disassemble_section(fasm, data, length, sec, procs, config);
            break;
         case TYPE_LEVEL:
            // relocate level scripts to .mio0 area
            // TODO: these shouldn't need to be relocated if load offset can be computed
            fprintf(fasm, ".space 0x%05x, 0x01 # %s\n", sec->end - sec->start, sec->label);
            break;
         case TYPE_BEHAVIOR:
            // behaviors are done below
            fprintf(fasm, ".space 0x%05x, 0x01 # %s\n", sec->end - sec->start, sec->label);
            break;
         default:
            ERROR("Don't know what to do with type %d\n", sec->type);
            exit(1);
            break;
      }
      last_end = sec->end;
   }

   // put MIO0 in separate data section and generate Makefile
   // allocate some space for the .bin makefile targets
   count = 1024; // header space
   level_alloc = 1024;
   i = strlen(" \\\n$(MIO0_DIR)/");
   j = strlen(" \\\n$(LEVEL_DIR)/");
   for (s = 0; s < config->section_count; s++) {
      split_section *sec = &sections[s];
      switch (sec->type) {
         case TYPE_MIO0:
            count += i + strlen(sec->label) + 4;
            break;
         case TYPE_LEVEL:
            level_alloc += j + strlen(sec->label) + 4;
            break;
         default:
            break;
      }
   }

   makeheader_mio0 = malloc(count);
   sprintf(makeheader_mio0, "MIO0_FILES =");

   makeheader_level = malloc(level_alloc);
   sprintf(makeheader_level, "LEVEL_FILES =");

   fmake = fopen(MAKEFILENAME, "w");
   fprintf(fmake, "LD_SCRIPT = %s/%s.ld\n\n", GEN_DIR, config->basename);
   fprintf(fmake, "MIO0_DIR = %s\n\n", MIO0_DIR);
   fprintf(fmake, "TEXTURE_DIR = %s\n\n", TEXTURE_DIR);
   fprintf(fmake, "LEVEL_DIR = %s\n\n", LEVEL_DIR);

   fprintf(fasm, "\n.section .mio0\n");
   for (s = 0; s < config->section_count; s++) {
      split_section *sec = &sections[s];
      switch (sec->type) {
         case TYPE_GEO:
            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(outfilename, "%s/%s.%06X.geo", BIN_DIR, config->basename, sec->start);
               sprintf(start_label, "L%06X", sec->start);
            } else {
               sprintf(outfilename, "%s/%s.geo", BIN_DIR, sec->label);
               strcpy(start_label, sec->label);
            }
            write_file(outfilename, &data[sec->start], sec->end - sec->start);
            fprintf(fasm, "\n.align 4, 0x01\n");
            fprintf(fasm, ".global %s\n", start_label);
            fprintf(fasm, "%s:\n", start_label);
            fprintf(fasm, ".incbin \"%s\"\n", outfilename);
            fprintf(fasm, "%s_end:\n", start_label);
            break;
         case TYPE_MIO0:
         {
            char binfilename[512];
            INFO("Section MIO0: %X-%X\n", sec->start, sec->end);
            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(outfilename, "%06X.mio0", sec->start);
            } else {
               sprintf(outfilename, "%s.mio0", sec->label);
            }
            sprintf(mio0filename, "%s/%s", MIO0_DIR, outfilename);
            write_file(mio0filename, &data[sec->start], sec->end - sec->start);
            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(start_label, "L%06X", sec->start);
            } else {
               strcpy(start_label, sec->label);
            }
            fprintf(fasm, "\n.align 4, 0x01\n");
            fprintf(fasm, ".global %s\n", start_label);
            fprintf(fasm, "%s:\n", start_label);
            fprintf(fasm, ".incbin \"%s\"\n", mio0filename);
            fprintf(fasm, "%s_end:\n", start_label);
            // append to Makefile
            sprintf(maketmp, " \\\n$(MIO0_DIR)/%s", outfilename);
            strcat(makeheader_mio0, maketmp);
            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(binfilename, "%s/%06X.bin", MIO0_DIR, sec->start);
            } else {
               sprintf(binfilename, "%s/%s.bin", MIO0_DIR, sec->label);
            }

            // extract MIO0 data
            mio0_decode_file(mio0filename, 0, binfilename);

            // extract texture data
            if (sec->extra) {
               texture *texts = sec->extra;
               int t;
               unsigned int offset = 0;
               sprintf(outfilepath, "%s/%s", TEXTURE_DIR, sec->label);
               make_dir(outfilepath);
               if (sec->label == NULL || sec->label[0] == '\0') {
                  fprintf(fmake, "$(MIO0_DIR)/%06X.bin:", sec->start);
               } else {
                  fprintf(fmake, "$(MIO0_DIR)/%s.bin: ", sec->label);
               }
               INFO("Extracting textures from %s\n", sec->label);
               for (t = 0; t < sec->extra_len; t++) {
                  w = texts[t].width;
                  h = texts[t].height;
                  offset = texts[t].offset;
                  switch (texts[t].format) {
                     case FORMAT_IA:
                     {
                        ia *img = file2ia(binfilename, offset, w, h, texts[t].depth);
                        if (img) {
                           sprintf(outfilepath, "%s/%s/0x%05X.ia%d.png", TEXTURE_DIR, sec->label, offset, texts[t].depth);
                           ia2png(img, w, h, outfilepath);
                           free(img);
                           fprintf(fmake, " %s", outfilepath);
                        }
                        break;
                     }
                     case FORMAT_RGBA:
                     {
                        rgba *img = file2rgba(binfilename, offset, w, h);
                        if (img) {
                           sprintf(outfilepath, "%s/%s/0x%05X.png", TEXTURE_DIR, sec->label, offset);
                           rgba2png(img, w, h, outfilepath);
                           free(img);
                           fprintf(fmake, " %s", outfilepath);
                        }
                        break;
                     }
                     case FORMAT_SKYBOX:
                     {
                        // read in grid of MxN 32x32 tiles and save them as M*31xN*31 image
                        rgba *img;
                        unsigned int sky_offset = offset;
                        int m, n;
                        int tx, ty;
                        m = w/32;
                        n = h/32;
                        img = malloc(w*h*sizeof(rgba));
                        w -= m; // adjust for overlap
                        h -= n;
                        for (ty = 0; ty < n; ty++) {
                           for (tx = 0; tx < m; tx++) {
                              rgba *tile = file2rgba(binfilename, sky_offset, 32, 32);
                              int cx, cy;
                              for (cy = 0; cy < 31; cy++) {
                                 for (cx = 0; cx < 31; cx++) {
                                    int out_off = 31*w*ty + 31*tx + w*cy + cx;
                                    int in_off = 32*cy+cx;
                                    img[out_off] = tile[in_off];
                                 }
                              }
                              free(tile);
                              sky_offset += 32*32*2;
                           }
                        }
                        sprintf(outfilepath, "%s/%s/0x%05X.skybox.png", TEXTURE_DIR, sec->label, offset);
                        rgba2png(img, w, h, outfilepath);
                        free(img);
                        fprintf(fmake, " %s", outfilepath);
                        break;
                     }
                     default:
                        ERROR("Don't know what to do with type %d\n", sec->type);
                        exit(1);
                  }
               }
               fprintf(fmake, "\n\t$(N64GRAPHICS) $@ $^\n\n");
            }
#if GENERATE_ALL_PNG
            sprintf(outfilepath, "%s/%s", TEXTURE_DIR, sec->label);
            make_dir(outfilepath);
            w = 32;
            h = filesize(binfilename) / (w * 2);
            rgba *img = file2rgba(binfilename, 0, w, h);
            if (img) {
               sprintf(outfilepath, "%s/%s/ALL.png", TEXTURE_DIR, sec->label);
               rgba2png(img, w, h, outfilepath);
               free(img);
               img = NULL;
            }
#endif // GENERATE_ALL_PNG
            // touch bin, then mio0 files so 'make' doesn't rebuild them right away
            touch_file(binfilename);
            touch_file(mio0filename);
            break;
         }
         case TYPE_LEVEL:
         {
            FILE *flevel;
            char levelfilename[512];
            INFO("Section relocated level: %X-%X\n", sec->start, sec->end);
            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(levelfilename, "%06X.s", sec->start);
            } else {
               sprintf(levelfilename, "%s.s", sec->label);
            }
            sprintf(outfilename, "%s/%s", LEVEL_DIR, levelfilename);

            // decode and write level data out
            flevel = fopen(outfilename, "w");
            if (flevel == NULL) {
               perror(outfilename);
               exit(1);
            }

            write_level(flevel, data, config, s);

            fclose(flevel);

            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(start_label, "L%06X", sec->start);
            } else {
               strcpy(start_label, sec->label);
            }
            fprintf(fasm, "\n.align 4, 0x01\n");
            fprintf(fasm, ".global %s\n", start_label);
            fprintf(fasm, "%s:\n", start_label);
            fprintf(fasm, ".include \"%s\"\n", outfilename);
            fprintf(fasm, "%s_end:\n", start_label);
            // append to Makefile
            sprintf(maketmp, " \\\n$(LEVEL_DIR)/%s", levelfilename);
            strcat(makeheader_level, maketmp);
            break;
         }
         case TYPE_BEHAVIOR:
         {
            FILE *f_beh;
            char beh_filename[512];
            INFO("Section relocated behavior: %X-%X\n", sec->start, sec->end);
            if (sec->label == NULL || sec->label[0] == '\0') {
               sprintf(beh_filename, "%06X.s", sec->start);
            } else {
               sprintf(beh_filename, "%s.s", sec->label);
            }
            sprintf(outfilename, "%s/%s", BEHAVIOR_DIR, beh_filename);
            // decode and write level data out
            f_beh = fopen(outfilename, "w");
            if (f_beh == NULL) {
               perror(outfilename);
               exit(1);
            }
            write_behavior(f_beh, data, config, s);
            fclose(f_beh);

            fprintf(fasm, "\n.section .behavior, \"a\"\n");
            fprintf(fasm, "\n.global %s\n", sec->label);
            fprintf(fasm, ".global %s_end\n", sec->label);
            fprintf(fasm, "%s:\n", sec->label);
            fprintf(fasm, ".include \"%s\"\n", outfilename);
            fprintf(fasm, "%s_end:\n", sec->label);
            fprintf(fasm, "\n\n.section .mio0\n");

            // append to Makefile
            sprintf(maketmp, " \\\n%s/%s", BEHAVIOR_DIR, beh_filename);
            strcat(makeheader_level, maketmp);
            break;
         }
         default:
            break;
      }
   }
   fprintf(fmake, "\n\n%s", makeheader_mio0);
   fprintf(fmake, "\n\n%s", makeheader_level);

   // cleanup
   free(makeheader_mio0);
   free(makeheader_level);
   fclose(fmake);
   fclose(fasm);

   generate_ld_script(config);
}

static void print_usage(void)
{
   ERROR("Usage: n64split [-c CONFIG] [-v] ROM\n"
         "\n"
         "n64split v" N64SPLIT_VERSION ": N64 ROM splitter, texture ripper, recursive disassembler\n"
         "\n"
         "Optional arguments:\n"
         " -c CONFIG    ROM configuration file (default: %s)\n"
         " -v           verbose progress output\n"
         "\n"
         "File arguments:\n"
         " ROM        input ROM file\n",
         default_args.config_file);
   exit(1);
}

// parse command line arguments
static void parse_arguments(int argc, char *argv[], arg_config *config)
{
   int i;
   int file_count = 0;
   if (argc < 2) {
      print_usage();
      exit(1);
   }
   for (i = 1; i < argc; i++) {
      if (argv[i][0] == '-') {
         switch (argv[i][1]) {
            case 'c':
               if (++i >= argc) {
                  print_usage();
               }
               strcpy(config->config_file, argv[i]);
               break;
            case 'v':
               g_verbosity = 1;
               break;
            default:
               print_usage();
               break;
         }
      } else {
         if (file_count == 0) {
            strcpy(config->input_file, argv[i]);
         } else {
            // too many
            print_usage();
         }
         file_count++;
      }
   }
   if (file_count < 1) {
      print_usage();
   }
}

int main(int argc, char *argv[])
{
   arg_config args;
   rom_config config;
   proc_table procs;
   long len;
   unsigned char *data;
   int ret_val;
   unsigned int size;
   unsigned int asm_size;
   float percent;
   int i;

   memset(&procs, 0, sizeof(procs));
   procs.count = 0;

   args = default_args;
   parse_arguments(argc, argv, &args);

   len = read_file(args.input_file, &data);

   if (len <= 0) {
      return 2;
   }

   ret_val = parse_config_file(args.config_file, &config);
   if (ret_val != 0) {
      return 2;
   }
   if (validate_config(&config, len)) {
      return 3;
   }

   // fill procs table from config labels
   mipsdisasm_add_procs(&procs, &config, len);

   // first pass disassembler
   mipsdisasm_pass1(data, len, &procs, &config);

   // split the ROM
   split_file(data, len, &procs, &config);

   // print some stats
   size = 0;
   asm_size = 0;
   for (i = 0; i < config.section_count; i++) {
      if (config.sections[i].type != TYPE_BIN) {
         size += config.sections[i].end - config.sections[i].start;
      }
      if (config.sections[i].type == TYPE_ASM) {
         asm_size += config.sections[i].end - config.sections[i].start;
      }
   }
   percent = (float)(100 * size) / (float)(len);
   printf("Total decoded section size: %X/%lX (%.2f%%)\n", size, len, percent);
   size = 0;
   for (i = 0; i < procs.count; i++) {
      size += procs.procedures[i].end - procs.procedures[i].start;
   }
   percent = (float)(100 * size) / (float)(asm_size);
   printf("Total disassembled ASM size:  %X/%X (%.2f%%)\n", size, asm_size, percent);

   return 0;
}

